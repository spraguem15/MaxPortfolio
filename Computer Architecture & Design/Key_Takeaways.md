<h1>Thoughts on experience</h1>

This class provided a lot of challenge, but also provided many valuable skills and knowledge as well. Below is more detail about the lessons learned as well as the challenges I faced while taking the class. 

<h2>Skills Learned</h2>

<h3>Programming skills</h3>

The primary language used in this class was SystemVerilog, which I had experience with before, but was able to refine further in this class. One example of something new I learned was regarding interfaces. Prior to this class, I was not familiar with interfaces, which are a clean and concise way of connecting multiple modules. We also used a lot of assembly in this class, as this is how we tested our design to ensure it worked as expected. I had also used assembly prior to this class, but it was good to refresh on the content I had once used. 

<h3>Design Skills</h3>

Before taking this class, I was fixed on the idea that computer architecture and other RTL design work was based on how well I could use HDLs such as SystemVerilog. I learned that the most important skill to have when working on projects like this is making sure you understand the design and key principles that you will be implementing. Anyone can simply turn these designs into code; however, understanding design choices is the key to creating a successful system. Using metrics such as CPI, Amdahl's Law, and the Iron Law are key ideas for optimizing a system and creating something new that will improve on the existing architecture. 

<h3>Testing</h3>

Something that goes hand in hand with design skills is proper testing. As depicted in the Design Progression document, this design got very large and complicated by the end of it. This meant testing and debugging our design would become increasingly more challenging as we went along. Something I learned very quickly is that if you do not foolproof your design with each iteration, there will be new issues appearing as you move on. Furthermore, knowing how a new addition will impact your design is very important because a new optimization might not work at first until an existing design is altered. Finally, making sure your testing environment is well organized is crucial for understanding what is happening in your system. We used QuestaSim waveforms to debug our system, which provided us with hundreds of different signals to be examined for correctness. Making sure that everything is properly organized is vital for ensuring that testing goes as planned.  

<h3>Computer Architecture & theory</h3>

Beyond the class project described in the other file we touched on many different topics useful for computer design and architecture. We covered different memory spaces going in depth on how they function as well as the different benefits of each. In addition to physical memory, virtual memory was discussed such as the translation process between physical and virtual addresses. We also touched on Simultaneously multi-threading and GPUs with their similarities/differences to CPUs. Finally, we also touched on I/O configuration and how they would function in association with the CPU. 
